//
//  This CSharp output file generated by Gardens Point LEX
//  Version:  1.0.1.250 (2009-01-01)
//  Machine:  macbook-pro-stas.local
//  DateTime: 16.12.2010 16:02:48
//  UserName: Stas
//  GPLEX input file <Scanner.lex>
//  GPLEX frame file <gplexx.frame>
//
//  Option settings: verbose, parser, minimize, compressnext
//

//
// gplexx.frame
// Version 1.0.0 of 01-November-2008
//
#define BACKUP
#define BYTEMODE

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
#if !STANDALONE
using gppg;
#endif

namespace L1Specializer
{   
    /// <summary>
    /// Summary Canonical example of GPLEX automaton
    /// </summary>
    
#if STANDALONE
    //
    // These are the dummy declarations for stand-alone GPLEX applications
    // normally these declarations would come from the parser.
    // If you declare /noparser, or %option noparser then you get this.
    //

    public enum Tokens
    { 
      EOF = 0, maxParseToken = int.MaxValue 
      // must have at least these two, values are almost arbitrary
    }

    public abstract class ScanBase
    {
        public abstract int yylex();
        protected virtual bool yywrap() { return true; }
#if BABEL
        protected abstract int CurrentSc { get; set; }
        // EolState is the 32-bit of state data persisted at 
        // the end of each line for Visual Studio colorization.  
        // The default is to return CurrentSc.  You must override
        // this if you want more complicated behavior.
        public virtual int EolState { 
            get { return CurrentSc; }
            set { CurrentSc = value; } 
        }
    }
    
    public interface IColorScan
    {
        void SetSource(string source, int offset);
        int GetNext(ref int state, out int start, out int end);
#endif // BABEL
    }

#endif // STANDALONE

    public abstract class ScanBuff
    {
        public const int EOF = -1;
        public abstract int Pos { get; set; }
        public abstract int Read();
        public abstract int Peek();
        public abstract int ReadPos { get; }
        public abstract string GetString(int b, int e);
        
        public const int UnicodeReplacementChar = 0xFFFD;
    }
    
    // If the compiler can't find ScanBase maybe you need to run
    // GPPG with the /gplex option, or GPLEX with /noparser
#if BABEL
    public sealed partial class Scanner : ScanBase, IColorScan
    {
        public ScanBuff buffer;
        int currentScOrd = 0;  // start condition ordinal
        
        protected override int CurrentSc 
        {
             // The current start state is a property
             // to try to avoid the user error of setting
             // scState but forgetting to update the FSA
             // start state "currentStart"
             //
             get { return currentScOrd; }  // i.e. return YY_START;
             set { currentScOrd = value;   // i.e. BEGIN(value);
                   currentStart = startState[value]; }
        }
#else  // BABEL
    public sealed partial class Scanner : ScanBase
    {
        public ScanBuff buffer;
        int currentScOrd = 0;  // start condition ordinal
#endif // BABEL
        
        private static int GetMaxParseToken() {
            System.Reflection.FieldInfo f = typeof(Tokens).GetField("maxParseToken");
            return (f == null ? int.MaxValue : (int)f.GetValue(null));
        }
        
        static int parserMax = GetMaxParseToken();
        
        enum Result {accept, noMatch, contextFound};

        const int maxAccept = 122;
        const int initial = 1;
        const int eofNum = 0;
        const int goStart = -1;
        const int INITIAL = 0;

#region user code
#endregion user code

        int state;
        int currentStart = startState[0];
        int chr;           // last character read
        int cNum = 0;      // ordinal number of chr
        int lNum = 0;      // current line number
        int lineStartNum;  // ordinal number at start of line
        //
        // The following instance variables are used, among other
        // things, for constructing the yylloc location objects.
        //
        int tokPos;        // buffer position at start of token
        int tokNum;        // ordinal number of first character
        int tokLen;        // number of characters in token
        int tokCol;        // zero-based column number at start of token
        int tokLin;        // line number at start of token
        int tokEPos;       // buffer position at end of token
        int tokECol;       // column number at end of token
        int tokELin;       // line number at end of token
        string tokTxt;     // lazily constructed text of token
#if STACK          
        private Stack<int> scStack = new Stack<int>();
#endif // STACK

#region ScannerTables
    struct Table {
        public int min; public int rng; public int dflt;
        public short[] nxt;
        public Table(int m, int x, int d, short[] n) {
            min = m; rng = x; dflt = d; nxt = n;
        }
    };

    static int[] startState = {1, 0};

    static Table[] NxS = new Table[130];

    static Scanner() {
    NxS[0] = new Table(0, 0, 0, null); // Shortest string ""
    NxS[1] = // Shortest string ""
      new Table(9, 115, 2, new short[] {3, 3, 2, 2, 4, 2, 
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
          2, 3, 2, 5, 6, 7, 2, 2, 8, 9, 10, 11, 12, 13, 14, 2, 
          15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 18, 19, 20, 21, 
          2, 2, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 25, 
          23, 23, 23, 23, 23, 26, 23, 23, 23, 23, 23, 23, 27, 2, 28, 2, 
          2, 2, 29, 30, 23, 31, 32, 23, 23, 23, 33, 23, 23, 23, 34, 35, 
          36, 23, 23, 37, 38, 39, 23, 23, 40, 41, 23, 23, 42});
    NxS[2] = new Table(0, 0, -1, null); // Shortest string "\x01"
    NxS[3] = // Shortest string "\t"
      new Table(9, 24, -1, new short[] {3, 3, -1, -1, 129, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, 3});
    NxS[4] = // Shortest string "\r"
      new Table(10, 1, -1, new short[] {3});
    NxS[5] = // Shortest string "\""
      new Table(10, 25, 128, new short[] {-1, 128, 128, -1, 128, 128, 
          128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 
          128, 128, 122});
    NxS[6] = // Shortest string "#"
      new Table(48, 76, -1, new short[] {120, 120, 120, 120, 120, 120, 
          120, 120, 120, 120, -1, -1, -1, -1, -1, -1, -1, 120, 120, 120, 120, 120, 
          120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 
          120, 120, 120, 120, 120, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, 126});
    NxS[7] = // Shortest string "$"
      new Table(48, 43, -1, new short[] {119, 119, 119, 119, 119, 119, 
          119, 119, 119, 119, -1, -1, -1, -1, -1, -1, -1, 119, 119, 119, 119, 119, 
          119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 
          119, 119, 119, 119, 119});
    NxS[8] = // Shortest string "'"
      new Table(10, 30, 125, new short[] {-1, 125, 125, -1, 125, 125, 
          125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 
          125, 125, -1, 125, 125, 125, 125, 117});
    NxS[9] = new Table(0, 0, -1, null); // Shortest string "("
    NxS[10] = new Table(0, 0, -1, null); // Shortest string ")"
    NxS[11] = // Shortest string "*"
      new Table(42, 1, -1, new short[] {116});
    NxS[12] = new Table(0, 0, -1, null); // Shortest string "+"
    NxS[13] = new Table(0, 0, -1, null); // Shortest string ","
    NxS[14] = new Table(0, 0, -1, null); // Shortest string "-"
    NxS[15] = new Table(0, 0, -1, null); // Shortest string "/"
    NxS[16] = // Shortest string "0"
      new Table(48, 10, -1, new short[] {16, 16, 16, 16, 16, 16, 
          16, 16, 16, 16});
    NxS[17] = // Shortest string ":"
      new Table(61, 1, -1, new short[] {115});
    NxS[18] = new Table(0, 0, -1, null); // Shortest string ";"
    NxS[19] = // Shortest string "<"
      new Table(61, 2, -1, new short[] {113, 114});
    NxS[20] = new Table(0, 0, -1, null); // Shortest string "="
    NxS[21] = // Shortest string ">"
      new Table(61, 1, -1, new short[] {112});
    NxS[22] = // Shortest string "A"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 102, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[23] = // Shortest string "B"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[24] = // Shortest string "F"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[25] = // Shortest string "N"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 99, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[26] = // Shortest string "T"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[27] = new Table(0, 0, -1, null); // Shortest string "["
    NxS[28] = new Table(0, 0, -1, null); // Shortest string "]"
    NxS[29] = // Shortest string "a"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 88, 23, 23, 23, 89, 90, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[30] = // Shortest string "b"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 85, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[31] = // Shortest string "d"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 79, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 80, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[32] = // Shortest string "e"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 72, 23, 73, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[33] = // Shortest string "i"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          69, 23, 23, 23, 23, 23, 23, 23, 70, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[34] = // Shortest string "m"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 67, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[35] = // Shortest string "n"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 63, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 64, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[36] = // Shortest string "o"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 62, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[37] = // Shortest string "r"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 57, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[38] = // Shortest string "s"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 54, 23, 
          23, 23, 23, 23, 23});
    NxS[39] = // Shortest string "t"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 50, 23, 23, 23, 23, 23, 23, 51, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[40] = // Shortest string "w"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 46, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[41] = // Shortest string "x"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 44, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[42] = // Shortest string "{"
      new Table(48, 10, -1, new short[] {123, 123, 123, 123, 123, 123, 
          123, 123, 123, 123});
    NxS[43] = // Shortest string "{0}0"
      new Table(48, 75, -1, new short[] {43, 43, 43, 43, 43, 43, 
          43, 43, 43, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, 43, 43, 43, 43, 
          43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 
          43, 43, 43, 43, 43});
    NxS[44] = // Shortest string "xo"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 45, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[45] = // Shortest string "xor"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[46] = // Shortest string "wh"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 47, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[47] = // Shortest string "whi"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 48, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[48] = // Shortest string "whil"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 49, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[49] = // Shortest string "while"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[50] = // Shortest string "th"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 52, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[51] = // Shortest string "to"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[52] = // Shortest string "the"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 53, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[53] = // Shortest string "then"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[54] = // Shortest string "st"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 55, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[55] = // Shortest string "ste"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 56, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[56] = // Shortest string "step"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[57] = // Shortest string "re"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 58, 23, 
          23, 23, 23, 23, 23});
    NxS[58] = // Shortest string "ret"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 59, 
          23, 23, 23, 23, 23});
    NxS[59] = // Shortest string "retu"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 60, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[60] = // Shortest string "retur"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 61, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[61] = // Shortest string "return"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[62] = // Shortest string "or"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[63] = // Shortest string "ne"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 66, 23, 23, 23});
    NxS[64] = // Shortest string "no"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 65, 23, 
          23, 23, 23, 23, 23});
    NxS[65] = // Shortest string "not"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[66] = // Shortest string "new"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[67] = // Shortest string "mo"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 68, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[68] = // Shortest string "mod"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[69] = // Shortest string "if"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[70] = // Shortest string "in"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 71, 23, 
          23, 23, 23, 23, 23});
    NxS[71] = // Shortest string "int"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[72] = // Shortest string "el"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 75, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[73] = // Shortest string "en"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 74, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[74] = // Shortest string "end"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[75] = // Shortest string "els"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 76, 
          23, 23, 23, 77, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[76] = // Shortest string "else"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[77] = // Shortest string "elsi"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          78, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[78] = // Shortest string "elsif"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[79] = // Shortest string "de"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          81, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[80] = // Shortest string "do"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[81] = // Shortest string "def"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 82, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[82] = // Shortest string "defi"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 83, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[83] = // Shortest string "defin"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 84, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[84] = // Shortest string "define"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[85] = // Shortest string "bo"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 86, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[86] = // Shortest string "boo"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 87, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[87] = // Shortest string "bool"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[88] = // Shortest string "an"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 98, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[89] = // Shortest string "ar"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 95, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[90] = // Shortest string "as"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 91, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[91] = // Shortest string "ass"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 92, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[92] = // Shortest string "asse"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 93, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[93] = // Shortest string "asser"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 94, 23, 
          23, 23, 23, 23, 23});
    NxS[94] = // Shortest string "assert"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[95] = // Shortest string "arr"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 96, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[96] = // Shortest string "arra"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 97, 23});
    NxS[97] = // Shortest string "array"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[98] = // Shortest string "and"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[99] = // Shortest string "NU"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 100, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[100] = // Shortest string "NUL"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 101, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[101] = // Shortest string "NULL"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[102] = // Shortest string "Ar"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 103, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[103] = // Shortest string "Arr"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 104, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[104] = // Shortest string "Arra"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 105, 23});
    NxS[105] = // Shortest string "Array"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 106, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[106] = // Shortest string "ArrayL"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 107, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[107] = // Shortest string "ArrayLe"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 108, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[108] = // Shortest string "ArrayLen"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 109, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[109] = // Shortest string "ArrayLeng"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 110, 23, 
          23, 23, 23, 23, 23});
    NxS[110] = // Shortest string "ArrayLengt"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 111, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[111] = // Shortest string "ArrayLength"
      new Table(48, 75, -1, new short[] {23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, -1, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, -1, -1, -1, -1, -1, -1, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
          23, 23, 23, 23, 23});
    NxS[112] = new Table(0, 0, -1, null); // Shortest string ">="
    NxS[113] = new Table(0, 0, -1, null); // Shortest string "<="
    NxS[114] = new Table(0, 0, -1, null); // Shortest string "<>"
    NxS[115] = new Table(0, 0, -1, null); // Shortest string ":="
    NxS[116] = new Table(0, 0, -1, null); // Shortest string "**"
    NxS[117] = new Table(0, 0, -1, null); // Shortest string "''"
    NxS[118] = new Table(0, 0, -1, null); // Shortest string "'\x01'"
    NxS[119] = // Shortest string "$0"
      new Table(48, 43, -1, new short[] {119, 119, 119, 119, 119, 119, 
          119, 119, 119, 119, -1, -1, -1, -1, -1, -1, -1, 119, 119, 119, 119, 119, 
          119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 
          119, 119, 119, 119, 119});
    NxS[120] = // Shortest string "#0"
      new Table(48, 43, -1, new short[] {120, 120, 120, 120, 120, 120, 
          120, 120, 120, 120, -1, -1, -1, -1, -1, -1, -1, 120, 120, 120, 120, 120, 
          120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 
          120, 120, 120, 120, 120});
    NxS[121] = new Table(0, 0, -1, null); // Shortest string "#{0}"
    NxS[122] = new Table(0, 0, -1, null); // Shortest string "\"\""
    NxS[123] = // Shortest string "{0"
      new Table(48, 78, -1, new short[] {123, 123, 123, 123, 123, 123, 
          123, 123, 123, 123, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, 124});
    NxS[124] = // Shortest string "{0}"
      new Table(48, 75, -1, new short[] {43, 43, 43, 43, 43, 43, 
          43, 43, 43, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, 43, 43, 43, 43, 
          43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 
          43, 43, 43, 43, 43});
    NxS[125] = // Shortest string "'\x01"
      new Table(39, 1, -1, new short[] {118});
    NxS[126] = // Shortest string "#{"
      new Table(48, 55, -1, new short[] {127, 127, 127, 127, 127, 127, 
          127, 127, 127, 127, -1, -1, -1, -1, -1, -1, -1, 127, 127, 127, 127, 127, 
          127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 127, 127, 127, 127, 127, 
          127});
    NxS[127] = // Shortest string "#{0"
      new Table(48, 78, -1, new short[] {127, 127, 127, 127, 127, 127, 
          127, 127, 127, 127, -1, -1, -1, -1, -1, -1, -1, 127, 127, 127, 127, 127, 
          127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 127, 127, 127, 127, 127, 
          127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, 121});
    NxS[128] = // Shortest string "\"\x01"
      new Table(10, 25, 128, new short[] {-1, 128, 128, -1, 128, 128, 
          128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 
          128, 128, 122});
    NxS[129] = // Shortest string "\t\r"
      new Table(10, 1, -1, new short[] {3});
    }

int NextState(int qStat) {
    if (chr == ScanBuff.EOF)
        return eofNum;
    else {
        int rslt;
        int idx = (byte)(chr - NxS[qStat].min);
        if ((uint)idx >= (uint)NxS[qStat].rng) rslt = NxS[qStat].dflt;
        else rslt = NxS[qStat].nxt[idx];
        return rslt;
    }
}

int NextState() {
    if (chr == ScanBuff.EOF)
        return eofNum;
    else {
        int rslt;
        int idx = (byte)(chr - NxS[state].min);
        if ((uint)idx >= (uint)NxS[state].rng) rslt = NxS[state].dflt;
        else rslt = NxS[state].nxt[idx];
        return rslt;
    }
}

// EXPERIMENTAL: This is the NextState method that
// is used by the CharClassPredicate functions for V0.9
int TestNextState(int qStat, int chr) {
    if (chr == ScanBuff.EOF)
        return eofNum;
    else {
        int rslt;
        int idx = (byte)(chr - NxS[qStat].min);
        if ((uint)idx >= (uint)NxS[qStat].rng) rslt = NxS[qStat].dflt;
        else rslt = NxS[qStat].nxt[idx];
        return rslt;
    }
}

#endregion


#if BACKUP
        // ==============================================================
        // == Nested class used for backup in automata which do backup ==
        // ==============================================================

        internal class Context // class used for automaton backup.
        {
            public int bPos;
            public int cNum;
            public int lNum; // Need this in case of backup over EOL.
            public int state;
            public int cChr;
        }
#endif // BACKUP

        // ==============================================================
        // ==== Nested struct to support input switching in scanners ====
        // ==============================================================

		struct BufferContext {
			internal ScanBuff buffSv;
			internal int chrSv;
			internal int cNumSv;
			internal int lNumSv;
			internal int startSv;
		}
		
#region Buffer classes

        // ==============================================================
        // ===== Private methods to save and restore buffer contexts ====
        // ==============================================================

        /// <summary>
        /// This method creates a buffer context record from
        /// the current buffer object, together with some
        /// scanner state values. 
        /// </summary>
		BufferContext MkBuffCtx()
		{
			BufferContext rslt;
			rslt.buffSv = this.buffer;
			rslt.chrSv = this.chr;
			rslt.cNumSv = this.cNum;
			rslt.lNumSv = this.lNum;
			rslt.startSv = this.lineStartNum;
			return rslt;
		}

        /// <summary>
        /// This method restores the buffer value and allied
        /// scanner state from the given context record value.
        /// </summary>
		void RestoreBuffCtx(BufferContext value)
		{
			this.buffer = value.buffSv;
			this.chr = value.chrSv;
			this.cNum = value.cNumSv;
			this.lNum = value.lNumSv;
			this.lineStartNum = value.startSv;
        } 
        
        // ==============================================================
        // ===== Nested classes for various ScanBuff derived classes ====
        // ==============================================================
        // =============== Nested class for string input ================
        // ==============================================================

        /// <summary>
        /// This class read characters from a single string as
        /// required, for example, by Visual Studio language services
        /// </summary>
        public sealed class StringBuff : ScanBuff
        {
            string str;        // input buffer
            int bPos;          // current position in buffer
            int sLen;

            public StringBuff(string str)
            {
                this.str = str;
                this.sLen = str.Length;
            }

            private int Read16()
            {
                if (bPos < sLen) return str[bPos++];
#if BABEL
                else if (bPos == sLen) { bPos++; return '\n'; }   // one strike, see newline
#endif // BABEL
                else { bPos++; return EOF; }                      // two strikes and you're out!
            }
            
            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int utf16 = Read16();
                if (utf16 < 0xD800 || utf16 > 0xDBFF)
                    return utf16;
                else
                {
                    int low16 = Read16();
                    if (low16 < 0xDC00 || low16 > 0xDFFF)
                        return UnicodeReplacementChar;
                    else
                        return (0x10000 + (utf16 & 0x3FF << 10) + (low16 & 0x3FF));
                }
            }
            
            public override int ReadPos { get { return bPos - 1; } }

            public override int Peek()
            {
                if (bPos < sLen) return str[bPos];
                else return '\n';
            }

            public override string GetString(int beg, int end)
            {
                //  "end" can be greater than sLen with the BABEL
                //  option set.  Read returns a "virtual" EOL if
                //  an attempt is made to read past the end of the
                //  string buffer.  Without the guard any attempt 
                //  to fetch yytext for a token that includes the 
                //  EOL will throw an index exception.
                if (end > sLen) end = sLen;
                if (end <= beg) return ""; 
                else return str.Substring(beg, end - beg);
            }

            public override int Pos
            {
                get { return bPos; }
                set { bPos = value; }
            }
        }

#if !NOFILES
       // ====================== Nested class ==========================
       //  The LineBuff class contributed by Nigel Horspool, 
       //  nigelh@cs.uvic.cs
       // ==============================================================

        public sealed class LineBuff : ScanBuff
        {
            IList<string> line;    // list of source lines from a file
            int numLines;          // number of strings in line list
            string curLine;        // current line in that list
            int cLine;             // index of current line in the list
            int curLen;            // length of current line
            int curLineStart;      // position of line start in whole file
            int curLineEnd;        // position of line end in whole file
            int maxPos;            // max position ever visited in whole file
            int cPos;              // ordinal number of chr in source

            // Constructed from a list of strings, one per source line.
            // The lines have had trailing '\n' characters removed.
            public LineBuff(IList<string> lineList)
            {
                line = lineList;
                numLines = line.Count;
                cPos = curLineStart = 0;
                curLine = (numLines>0 ? line[0] : "");
                maxPos = curLineEnd = curLen = curLine.Length;
                cLine = 1;
            }

            public override int Read()
            {
                if (cPos < curLineEnd)
                    return curLine[cPos++ - curLineStart];
                if (cPos++ == curLineEnd)
                    return '\n';
                if (cLine >= numLines)
                    return EOF;
                curLine = line[cLine];
                curLen = curLine.Length;
                curLineStart = curLineEnd + 1;
                curLineEnd = curLineStart + curLen;
                if (curLineEnd>maxPos)
                    maxPos = curLineEnd;
                cLine++;
                return curLen>0? curLine[0] : '\n';
            }

            public override int Peek()
            {
                return (cPos < curLineEnd)? curLine[cPos - curLineStart] : '\n';
            }

            // To speed up searches for the line containing a position
            private int cachedPos = 0;
            private int cachedIx = 0;
            private int cachedLstart = 0;

            // Given a position pos within the entire source, the results are
            //   ix     -- the index of the containing line
            //   lstart -- the position of the first character on that line
            private void findIndex( int pos, out int ix, out int lstart )
            {
                if (pos >= cachedPos) {
                    ix = cachedIx;  lstart = cachedLstart;
                } else {
                    ix = lstart = 0;
                }
                for( ; ; ) {
                    int len = line[ix].Length + 1;
                    if (pos < lstart+len) break;
                    lstart += len;
                    ix++;
                }
                cachedPos = pos;
                cachedIx = ix;
                cachedLstart = lstart;
            }
        
            public override string GetString(int beg, int end)
            {
                if (beg >= maxPos || end <= beg) return "";
                int endIx, begIx, endLineStart, begLineStart;
                findIndex(beg, out begIx, out begLineStart);
                int begCol = beg - begLineStart;
                findIndex(end, out endIx, out endLineStart);
                int endCol = end - endLineStart;
                string s = line[begIx];
                if (begIx == endIx) {
                    // the usual case, substring all on one line
                    return (endCol <= s.Length)?
                        s.Substring(begCol, endCol-begCol)
                        : s.Substring(begCol) + "\n";
                }
                // the string spans multiple lines, yuk!
                StringBuilder sb = new StringBuilder();
                if (begCol < s.Length)
                    sb.Append(s.Substring(begCol));
                for( ; ; ) {
                    sb.Append("\n");
                    s = line[++begIx];
                    if (begIx >= endIx) break;
                    sb.Append(s);
                }
                if (endCol <= s.Length) {
                    sb.Append(s.Substring(0, endCol));
                } else {
                    sb.Append(s);
                    sb.Append("\n");
                }
                return sb.ToString();
            }

            public override int Pos
            {
                get { return cPos; }
                set {
                    cPos = value;
                    findIndex(cPos, out cLine, out curLineStart);
                    curLine = line[cLine];
                    curLineEnd = curLineStart+curLine.Length;
                }
            }
            
            public override int ReadPos { get { return cPos - 1; } }
        }
        
        // ==============================================================
        // =========== Nested class StreamBuff : byte files =============
        // ==============================================================

        /// <summary>
        /// This is the Buffer for byte files. It returns 8-bit characters.
        /// </summary>
        public class StreamBuff : ScanBuff
        {
            protected BufferedStream bStrm;   // input buffer
            protected int delta = 1;          // number of bytes in chr, could be 0 for EOF.

            public StreamBuff(Stream str) { this.bStrm = new BufferedStream(str); }

            /// <summary>
            /// Read returns subset [0 .. 0xFF] in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFF]; -1 for EOF</returns>
            public override int Read() {
                int ch0 = bStrm.ReadByte();
                delta = (ch0 == EOF ? 0 : 1);
                return ch0; 
            }
            
            public override int ReadPos {
                get { return (int)bStrm.Position - delta; }
            }

            public override int Peek()
            {
                int rslt = bStrm.ReadByte();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)bStrm.ReadByte();
                bStrm.Position = savePos;
                return new String(arr);
            }

            // Pos is the position *after* reading chr!
            public override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
            
            public static int GetCodePage(string command)
            {
                command = command.ToLower();
                if (command.StartsWith("codepage:"))
                    command = command.Substring(9);
                try
                {
                    if (command.Equals("raw"))
                        return -1;
                    else if (command.Equals("guess"))
                        return -2;
                    else if (command.Equals("default"))
                        return 0;
                    else if (char.IsDigit(command[0]))
                        return int.Parse(command);
                    else
                    {
                        Encoding enc = Encoding.GetEncoding(command);
                        return enc.CodePage;
                    }
                }
                catch
                {
                    Console.Error.WriteLine(
                        "Unknown codepage \"{0}\", using machine default", command);
                    return 0;
                }
            }
        }

#if !BYTEMODE       
        // ==============================================================
        // ===== Nested class CodePageBuff : for unicode text files =====
        // ========= Byte files mapped by a specified CodePage ==========
        // ==============================================================

        public sealed class CodePageBuff : StreamBuff
        {
        
            char[] map = new char[256];
            
            public CodePageBuff(Stream stream) : this(stream, Encoding.Default) { }

            
            public CodePageBuff(Stream stream, Encoding enc) : base(stream)
            {
                bool done;
                int bNum, cNum;
                byte[] bArray = new byte[256];
                if (!enc.IsSingleByte)
                    throw new NotImplementedException(
                        "Only UTF-8, UTF-16 and single-byte code pages allowed");
                Decoder decoder = enc.GetDecoder();
                for (int i = 0; i < 256; i++)
                    bArray[i] = (byte)i;
                decoder.Convert(bArray, 0, 256, this.map, 0, 256, true, out bNum, out cNum, out done);
            }
            
            /// <summary>
            /// Read returns subset unicode char corresponding to the
            /// given character in the chosen codepage.
            /// </summary>
            /// <returns>Unicode point as an int; -1 for EOF</returns>
            public override int Read() {
                int ch0 = bStrm.ReadByte();
                if (ch0 == EOF)
                {
                    delta = 0; return -1;
                }
                else
                {
                    delta = 1; return this.map[ch0];
                } 
            }
            
            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr);
            }
        }
        

        // ==============================================================
        // ====== Nested class TextBuff : for unicode text files ========
        // ==== This is the UTF8 class, UTF16 handled by subclasses =====
        // ==============================================================

        /// <summary>
        /// This is the Buffer for UTF8 files.
        /// It attempts to read the encoding preamble, which for 
        /// this encoding should be unicode point \uFEFF which is 
        /// encoded as EF BB BF
        /// </summary>
        public class TextBuff : ScanBuff
        {
            protected BufferedStream bStrm;   // input buffer
            protected int delta = 1;          // length of chr, zero for EOF!
            

            /// <summary>
            /// TextBuff factory.  Reads the file preamble
            /// and returns a TextBuff, LittleEndTextBuff or
            /// BigEndTextBuff according to the result.
            /// </summary>
            /// <param name="strm">The underlying stream</param>
            /// <returns></returns>
            public static ScanBuff NewTextBuff(Stream strm, int fallbackCodepage)
            {
                // First check if this is a UTF16 file
                //
                int b0 = strm.ReadByte();
                int b1 = strm.ReadByte();

                if (b0 == 0xfe && b1 == 0xff)
                    return new BigEndTextBuff(strm);
                if (b0 == 0xff && b1 == 0xfe)
                    return new LittleEndTextBuff(strm);
                
                int b2 = strm.ReadByte();
                if (b0 == 0xef && b1 == 0xbb && b2 == 0xbf)
                    return new TextBuff(strm);
                //
                // There is no unicode preamble, so
                // we go back to the bytefile default.
                //
                strm.Seek(0, SeekOrigin.Begin);
                
                switch (fallbackCodepage)
                {
                    case -2:
                        {
                            int guess = new Guesser.Scanner(strm).GuessCodepage();
                            strm.Seek(0, SeekOrigin.Begin);
                            if (guess == 0)
                                return new CodePageBuff(strm);
                            else if (guess == 65001)
                                return new TextBuff(strm);
                            else
                                return new StreamBuff(strm);
                        }                        
                    case -1:
                        return new StreamBuff(strm);
                    case 0:
                        return new CodePageBuff(strm); // Default codepage
                    case 65001:
                        return new TextBuff(strm);
                    case 1200:
                        return new LittleEndTextBuff(strm);
                    case 1201:
                        return new BigEndTextBuff(strm);
                    default:
                        return new CodePageBuff(strm, Encoding.GetEncoding(fallbackCodepage));
                }
            }

            protected TextBuff(Stream str) { 
                this.bStrm = new BufferedStream(str);
            }

            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1, ch2, ch3,ch4, ch5;
                int result = UnicodeReplacementChar;

                if (ch0 < 0x7f)
                {
                    delta = (ch0 == EOF ? 0 : 1);
                    result = ch0;
                }
                else if ((ch0 & 0xe0) == 0xc0)
                {
                    delta = 2;
                    ch1 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80)
                        result = ((ch0 & 0x1f) << 6) + (ch1 & 0x3f);
                }
                else if ((ch0 & 0xf0) == 0xe0)
                {
                    delta = 3;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80)
                        result = ((ch0 & 0xf) << 12) + ((ch1 & 0x3f) << 6) + (ch2 & 0x3f);
                }
                else if ((ch0 & 0xf8) == 0xf0)
                {
                    delta = 4;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte(); ch3 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80 && (ch3 & 0xc0) == 0x80)
                    {
                        result = ((ch0 & 0x7) << 18) + ((ch1 & 0x3f) << 12) + 
                                 ((ch2 & 0x3f) << 6) + (ch3 & 0x3f);
                    }
                }
                else if ((ch0 & 0xfc) == 0xf8)
                {
                    delta = 5;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte();
                    ch3 = bStrm.ReadByte(); ch4 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80 && (ch3 & 0xc0) == 0x80 && (ch4 & 0xc0) == 0x80)
                    {
                        result = ((ch0 & 0x3) << 24) + ((ch1 & 0x3f) << 18) + 
                                     ((ch2 & 0x3f) << 12) + ((ch3 & 0x3f) << 6) + (ch4 & 0x3f);
                    }
                }
                else if ((ch0 & 0xfe) == 0xfc)
                {
                    delta = 6;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte(); ch3 = bStrm.ReadByte();
                    ch4 = bStrm.ReadByte(); ch5 = bStrm.ReadByte();

                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80 && 
                        (ch3 & 0xc0) == 0x80 && (ch4 & 0xc0) == 0x80 && (ch5 & 0xc0) == 0x80)
                    {
                        result = ((ch0 & 0x1) << 28) + ((ch1 & 0x3f) << 24) + ((ch2 & 0x3f) << 18) + 
                                     ((ch3 & 0x3f) << 12) + ((ch4 & 0x3f) << 6) + (ch5 & 0x3f);
                    }
                }
                return result;
            }

            public sealed override int ReadPos
            {
                get { return (int)bStrm.Position - delta; }
            }

            public sealed override int Peek()
            {
                int rslt = Read();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                //
                //  The length of the array cannot be larger than
                //  end - beg, since if the characters expand by 
                //  using surrogate pairs the UTF8 must have taken
                //  up at least four bytes for any such character.
                //
                char[] arr = new char[end - beg];
                
                bStrm.Position = (long)beg;
                // Normally each call of Read() returns a valid UTF16
                // value which will take up one place in the string.
                // However, if read returns a value > 0xFFFF then a
                // *pair* of surrogate characters must be added.
                for (i = 0; bStrm.Position < end; i++)
                {
                    int value = Read();
                    if (value < 0xFFFF)
                        arr[i] = (char)value;
                    else
                    {
                        int temp = value - 0x10000;
                        arr[i++] = (char)(0xD800 + temp / 1024);
                        arr[i]   = (char)(0xDC00 + temp % 1024);
                    }
                }
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr, 0, i);
            }

            // Pos is the position *after* reading chr!
            public sealed override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }
        
        // ==============================================================
        // ====================== Nested class ==========================
        // ==============================================================
        
        /// <summary>
        /// This is the Buffer for Big-endian UTF16 files.
        /// </summary>
        public sealed class BigEndTextBuff : TextBuff
        {
            internal BigEndTextBuff(Stream str) : base(str) { } // 

            private int Read16()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch0 << 8) + ch1;
                }
            }
            
            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int utf16 = Read16();
                if (utf16 < 0xD800 || utf16 > 0xDBFF)
                    return utf16;
                else
                {
                    int low16 = Read16();
                    delta = 4;
                    if (low16 < 0xDC00 || low16 > 0xDFFF)
                        return UnicodeReplacementChar;
                    else
                        return (0x10000 + (utf16 & 0x3FF << 10) + (low16 & 0x3FF));
                }
            }
            
            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public sealed override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                // This stream will have utf16 valid for strings
                for (i = 0; bStrm.Position < end; i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr, 0, i);
            }
        }

        // ==============================================================
        // ====================== Nested class ==========================
        // ==============================================================
        
        /// <summary>
        /// This is the Buffer for Little-endian UTF16 files.
        /// </summary>
        public sealed class LittleEndTextBuff : TextBuff
        {
            internal LittleEndTextBuff(Stream str) : base(str) { } // { this.bStrm = new BufferedStream(str); }

            private int Read16()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch1 << 8) + ch0;
                }
            }
            
            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int utf16 = Read16();
                if (utf16 < 0xD800 || utf16 > 0xDBFF)
                    return utf16;
                else
                {
                    int low16 = Read16();
                    delta = 4;
                    if (low16 < 0xDC00 || low16 > 0xDFFF)
                        return UnicodeReplacementChar;
                    else
                        return (0x10000 + (utf16 & 0x3FF << 10) + (low16 & 0x3FF));
                }
            }
            
            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public sealed override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                // This stream will have utf16 valid for strings
                for (i = 0; bStrm.Position < end; i++)
                    arr[i] = (char)Read16();
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr, 0, i);
            }
        }
#endif // !BYTEMODE
#endif // !NOFILES
#endregion Buffer classes

        // =================== End Nested classes =======================

#if !NOFILES
        public Scanner(Stream file) {
            SetSource(file); // no unicode option
        }

        public Scanner(Stream file, string codepage) {
            SetSource(file); // Not unicode, ignoring codepage
        }
        
#endif // !NOFILES

        public Scanner() { }

        void GetChr()
        {
            if (chr == '\n')  // This needs to be fixed for other conventions
            { 
                lineStartNum = cNum + 1; 
                lNum++; 
            }
            chr = buffer.Read();
            cNum++;
        }

        void MarkToken()
        {
            tokPos = buffer.ReadPos;
            tokNum = cNum;
            tokLin = lNum;
            tokCol = cNum - lineStartNum;
        }
        
        void MarkEnd()
        {
            tokTxt = null;
            tokLen = cNum - tokNum;
            tokEPos = buffer.ReadPos;
            tokELin = lNum;
            tokECol = cNum - lineStartNum;
        }

        // ==============================================================
        // =====    Initialization of string-based input buffers     ====
        // ==============================================================

        /// <summary>
        /// Create and initialize a StringBuff buffer object for this scanner
        /// </summary>
        /// <param name="source">the input string</param>
        /// <param name="offset">starting offset in the string</param>
        public void SetSource(string source, int offset)
        {
            this.buffer = new StringBuff(source);
            this.buffer.Pos = offset;
            this.lNum = 0;
            this.cNum = offset - 1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }

#if !NOFILES        
        // ================ LineBuffer Initialization ===================

        /// <summary>
        /// Create and initialize a LineBuff buffer object for this scanner
        /// </summary>
        /// <param name="source">the list of input strings</param>
        public void SetSource(IList<string> source)
        {
            this.buffer = new LineBuff(source);
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            this.lNum = 0;
            this.cNum = -1;
            GetChr();
        }

        // =============== StreamBuffer Initialization ==================

        /// <summary>
        /// Create and initialize a StreamBuff buffer object for this scanner.
        /// StreamBuff is buffer for 8-bit byte files.
        /// </summary>
        /// <param name="source">the input byte stream</param>
        public void SetSource(Stream source)
        {
            this.buffer = new StreamBuff(source);
            this.lNum = 0;
            this.cNum = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }
        
#if !BYTEMODE
        // ================ TextBuffer Initialization ===================

        /// <summary>
        /// Create and initialize a TextBuff buffer object for this scanner.
        /// TextBuff is a buffer for encoded unicode files.
        /// </summary>
        /// <param name="source">the input text file</param>
        /// <param name="fallbackCodepage">Codepage to use if file has
        /// no BOM. For 0, use machine default; for -1, 8-bit binary</param>
        public void SetSource(Stream source, int fallbackCodepage)
        {
            this.buffer = TextBuff.NewTextBuff(source, fallbackCodepage);
            this.lNum = 0;
            this.cNum = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }
#endif // !BYTEMODE
#endif // !NOFILES
        
        // ==============================================================

#if BABEL
        //
        //  Get the next token for Visual Studio
        //
        //  "state" is the inout mode variable that maintains scanner
        //  state between calls, using the EolState property. In principle,
        //  if the calls of EolState are costly set could be called once
        //  only per line, at the start; and get called only at the end
        //  of the line. This needs more infrastructure ...
        //
        public int GetNext(ref int state, out int start, out int end)
        {
            Tokens next;
            int s, e;
            s = state;        // state at start
            EolState = state;
            next = (Tokens)Scan();
            state = EolState;
            e = state;       // state at end;
            start = tokPos;
            end = tokEPos - 1; // end is the index of last char.
            return (int)next;
        }        
#endif // BABEL

        // ======== IScanner<> Implementation =========

        public override int yylex()
        {
            // parserMax is set by reflecting on the Tokens
            // enumeration.  If maxParseToken is defined
            // that is used, otherwise int.MaxValue is used.
            int next;
            do { next = Scan(); } while (next >= parserMax);
            return next;
        }
        
        int yyleng { get { return tokLen; } }
        int yypos { get { return tokPos; } }
        int yyline { get { return tokLin; } }
        int yycol { get { return tokCol; } }

        public string yytext
        {
            get 
            {
                if (tokTxt == null) 
                    tokTxt = buffer.GetString(tokPos, tokEPos);
                return tokTxt;
            }
        }

        void yyless(int n) { 
            buffer.Pos = tokPos;
            // Must read at least one char, so set before start.
            cNum = tokNum - 1; GetChr();
            // Now ensure that line counting is correct.
            lNum = tokLin;
            // And count the rest of the text.
            for (int i = 0; i < n; i++) GetChr();
            MarkEnd();
        }

        // ============ methods available in actions ==============

        internal int YY_START {
            get { return currentScOrd; }
            set { currentScOrd = value; 
                  currentStart = startState[value]; 
            } 
        }
        
        internal void BEGIN(int next) {
            currentScOrd = next;
            currentStart = startState[next];
        }

        // ============== The main tokenizer code =================

        int Scan()
        {
                for (; ; )
                {
                    int next;              // next state to enter                   
#if BACKUP
                    Result rslt = Result.noMatch;
#endif // BACKUP
#if LEFTANCHORS
                    for (;;)
                    {
                        // Discard characters that do not start any pattern.
                        // Must check the left anchor condition after *every* GetChr!
                        state = (lineStartNum == cNum ? anchorState[currentScOrd] : currentStart);
                        if ((next = NextState()) != goStart) 
                            break; // LOOP EXIT HERE...
                        GetChr();
                    }
                    
#else // !LEFTANCHORS
                    state = currentStart;
                    while ((next = NextState()) == goStart)
                        // At this point, the current character has no
                        // transition from the current state.  We discard 
                        // the "no-match" char.   In traditional LEX such 
                        // characters are echoed to the console.
                        GetChr();
#endif // LEFTANCHORS                    
                    // At last, a valid transition ...    
                    MarkToken();
                    state = next;
                    GetChr();
                    
                    while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum
#if BACKUP
                        if (state <= maxAccept && next > maxAccept) // need to prepare backup data
                        {
                            // ctx is an object. The fields may be 
                            // mutated by the call to Recurse2.
                            // On return the data in ctx is the
                            // *latest* accept state that was found.
                            Context ctx = new Context();
                            rslt = Recurse2(ctx, next);
                            if (rslt == Result.noMatch) 
                                RestoreStateAndPos(ctx);
                            break;
                        }
                        else
#endif // BACKUP
                        {
                            state = next;
                            GetChr();
                        }
                    if (state <= maxAccept) 
                    {
                        MarkEnd();
#region ActionSwitch
#pragma warning disable 162
    switch (state)
    {
        case eofNum:
            if (yywrap())
                return (int)Tokens.EOF;
            break;
        case 1: // Recognized '(" "|\t|\n|\r\n)*',	Shortest string ""
        case 3: // Recognized '(" "|\t|\n|\r\n)*',	Shortest string "\t"
;
            break;
        case 2: // Recognized '.',	Shortest string "\x01"
        case 4: // Recognized '.',	Shortest string "\r"
        case 5: // Recognized '.',	Shortest string "\""
        case 6: // Recognized '.',	Shortest string "#"
        case 7: // Recognized '.',	Shortest string "$"
        case 8: // Recognized '.',	Shortest string "'"
        case 17: // Recognized '.',	Shortest string ":"
        case 42: // Recognized '.',	Shortest string "{"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ILLEGAL;
            break;
        case 9: // Recognized '"("',	Shortest string "("
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.LP;
            break;
        case 10: // Recognized '")"',	Shortest string ")"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.RP;
            break;
        case 11: // Recognized '"*"',	Shortest string "*"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.MULT;
            break;
        case 12: // Recognized '"+"',	Shortest string "+"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.PLUS;
            break;
        case 13: // Recognized '","',	Shortest string ","
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.SEMI;
            break;
        case 14: // Recognized '"-"',	Shortest string "-"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.MINUS;
            break;
        case 15: // Recognized '"/"',	Shortest string "/"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.DIV;
            break;
        case 16: // Recognized '[0-9]+',	Shortest string "0"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.iVal = Convert.ToInt32(yytext);
	return (int)Tokens.INTEGER;
            break;
        case 18: // Recognized '";"',	Shortest string ";"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.COMMA;
            break;
        case 19: // Recognized '"<"',	Shortest string "<"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.LE;
            break;
        case 20: // Recognized '"="',	Shortest string "="
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.EQ;
            break;
        case 21: // Recognized '">"',	Shortest string ">"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.GR;
            break;
        case 22: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "A"
        case 23: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "B"
        case 25: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "N"
        case 29: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "a"
        case 30: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "b"
        case 31: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "d"
        case 32: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "e"
        case 33: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "i"
        case 34: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "m"
        case 35: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "n"
        case 36: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "o"
        case 37: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "r"
        case 38: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "s"
        case 39: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "t"
        case 40: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "w"
        case 41: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "x"
        case 44: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "xo"
        case 46: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "wh"
        case 47: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "whi"
        case 48: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "whil"
        case 50: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "th"
        case 52: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "the"
        case 54: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "st"
        case 55: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ste"
        case 57: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "re"
        case 58: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ret"
        case 59: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "retu"
        case 60: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "retur"
        case 63: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ne"
        case 64: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "no"
        case 67: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "mo"
        case 70: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "in"
        case 72: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "el"
        case 73: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "en"
        case 75: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "els"
        case 77: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "elsi"
        case 79: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "de"
        case 81: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "def"
        case 82: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "defi"
        case 83: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "defin"
        case 85: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "bo"
        case 86: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "boo"
        case 88: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "an"
        case 89: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ar"
        case 90: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "as"
        case 91: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ass"
        case 92: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "asse"
        case 93: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "asser"
        case 95: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "arr"
        case 96: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "arra"
        case 99: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "NU"
        case 100: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "NUL"
        case 102: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "Ar"
        case 103: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "Arr"
        case 104: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "Arra"
        case 105: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "Array"
        case 106: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ArrayL"
        case 107: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ArrayLe"
        case 108: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ArrayLen"
        case 109: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ArrayLeng"
        case 110: // Recognized '([A-Za-z]([A-Za-z0-9])*)+',	Shortest string "ArrayLengt"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.sVal = yytext;
	return (int)Tokens.IDENTIFIER;
            break;
        case 24: // Recognized '"F"',	Shortest string "F"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.F;
            break;
        case 26: // Recognized '"T"',	Shortest string "T"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.T;
            break;
        case 27: // Recognized '"["',	Shortest string "["
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.LAP;
            break;
        case 28: // Recognized '"]"',	Shortest string "]"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.RAP;
            break;
        case 43: // Recognized '"{"[0-9]+"}"[0-9a-z]+',	Shortest string "{0}0"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.iVal = CompilerServices.ParseInt(yytext);
	return (int)Tokens.INTEGER;
            break;
        case 45: // Recognized '"xor"',	Shortest string "xor"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.XOR;
            break;
        case 49: // Recognized '"while"',	Shortest string "while"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.WHILE;
            break;
        case 51: // Recognized '"to"',	Shortest string "to"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.TO;
            break;
        case 53: // Recognized '"then"',	Shortest string "then"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.THEN;
            break;
        case 56: // Recognized '"step"',	Shortest string "step"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.STEP;
            break;
        case 61: // Recognized '"return"',	Shortest string "return"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.RETURN;
            break;
        case 62: // Recognized '"or"',	Shortest string "or"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.OR;
            break;
        case 65: // Recognized '"not"',	Shortest string "not"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.NOT;
            break;
        case 66: // Recognized '"new"',	Shortest string "new"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.NEW;
            break;
        case 68: // Recognized '"mod"',	Shortest string "mod"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.MOD;
            break;
        case 69: // Recognized '"if"',	Shortest string "if"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.IF;
            break;
        case 71: // Recognized '"int"',	Shortest string "int"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.INT;
            break;
        case 74: // Recognized '"end"',	Shortest string "end"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.END;
            break;
        case 76: // Recognized '"else"',	Shortest string "else"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ELSE;
            break;
        case 78: // Recognized '"elsif"',	Shortest string "elsif"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ELSIF;
            break;
        case 80: // Recognized '"do"',	Shortest string "do"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.DO;
            break;
        case 84: // Recognized '"define"',	Shortest string "define"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.DEFINE;
            break;
        case 87: // Recognized '"bool"',	Shortest string "bool"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.BOOL;
            break;
        case 94: // Recognized '"assert"',	Shortest string "assert"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ASSERT;
            break;
        case 97: // Recognized '"array"',	Shortest string "array"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ARRAY;
            break;
        case 98: // Recognized '"and"',	Shortest string "and"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.AND;
            break;
        case 101: // Recognized '"NULL"',	Shortest string "NULL"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.NULL;
            break;
        case 111: // Recognized '"ArrayLength"',	Shortest string "ArrayLength"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ARRAY_LENGTH;
            break;
        case 112: // Recognized '">="',	Shortest string ">="
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.GREQ;
            break;
        case 113: // Recognized '"<="',	Shortest string "<="
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.LEEQ;
            break;
        case 114: // Recognized '"<>"',	Shortest string "<>"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.NEQ;
            break;
        case 115: // Recognized '":="',	Shortest string ":="
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.ASSIGN;
            break;
        case 116: // Recognized '"**"',	Shortest string "**"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol); return (int)Tokens.POWER;
            break;
        case 117: // Recognized '"''"',	Shortest string "''"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.iVal = Convert.ToInt32('\'');
    return (int)Tokens.CHAR_LITERAL;
            break;
        case 118: // Recognized '"'"{CHAR_S}"'"',	Shortest string "'\x01'"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.iVal = Convert.ToInt32(Convert.ToChar(yytext.Substring(1, 1)));
    return (int)Tokens.CHAR_LITERAL;
            break;
        case 119: // Recognized '"$"[A-Z0-9]+',	Shortest string "$0"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.sVal = CompilerServices.GetCharLiteral(yytext.Substring(1, yytext.Length - 1)).ToString();
    return (int)Tokens.STRING_LITERAL;
            break;
        case 120: // Recognized '"#"[A-Z0-9]+',	Shortest string "#0"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.iVal = Convert.ToInt32(CompilerServices.GetCharLiteral(yytext.Substring(1, yytext.Length - 1)));
    return (int)Tokens.CHAR_LITERAL;
            break;
        case 121: // Recognized '"#{"[0-9a-fA-F]+"}"',	Shortest string "#{0}"
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.iVal = Convert.ToInt32(CompilerServices.ParseCharFromCode(yytext));
    return (int)Tokens.CHAR_LITERAL;
            break;
        case 122: // Recognized '"\""{STR_S}*"\""',	Shortest string "\"\""
yylloc = new LexLocation(tokLin,tokCol,tokELin,tokECol);
    yylval.sVal = yytext.Substring(1, yytext.Length - 2);
    return (int)Tokens.STRING_LITERAL;
            break;
        default:
            break;
    }
#pragma warning restore 162
#endregion
                    }
                }
        }

#if BACKUP
        Result Recurse2(Context ctx, int next)
        {
            // Assert: at entry "state" is an accept state AND
            //         NextState(state, chr) != goStart AND
            //         NextState(state, chr) is not an accept state.
            //
            SaveStateAndPos(ctx);
            state = next;
            // if (state == eofNum) return Result.accept;
            GetChr();

            while ((next = NextState()) > eofNum)
            {
                if (state <= maxAccept && next > maxAccept) // need to update backup data
                    SaveStateAndPos(ctx);
                state = next;
                if (state == eofNum) return Result.accept;
                GetChr(); 
            }
            return (state <= maxAccept ? Result.accept : Result.noMatch);
        }

        void SaveStateAndPos(Context ctx)
        {
            ctx.bPos  = buffer.Pos;
            ctx.cNum  = cNum;
            ctx.lNum  = lNum;
            ctx.state = state;
            ctx.cChr  = chr;
        }

        void RestoreStateAndPos(Context ctx)
        {
            buffer.Pos = ctx.bPos;
            cNum  = ctx.cNum;
            lNum  = ctx.lNum;
            state = ctx.state;
            chr   = ctx.cChr;
        }

        void RestorePos(Context ctx) { buffer.Pos = ctx.bPos; cNum = ctx.cNum; }
#endif // BACKUP

        // ============= End of the tokenizer code ================

#if STACK        
        internal void yy_clear_stack() { scStack.Clear(); }
        internal int yy_top_state() { return scStack.Peek(); }
        
        internal void yy_push_state(int state)
        {
            scStack.Push(currentScOrd);
            BEGIN(state);
        }
        
        internal void yy_pop_state()
        {
            // Protect against input errors that pop too far ...
            if (scStack.Count > 0) {
				int newSc = scStack.Pop();
				BEGIN(newSc);
            } // Otherwise leave stack unchanged.
        }
 #endif // STACK

        internal void ECHO() { Console.Out.Write(yytext); }
        
    } // end class Scanner
} // end namespace
