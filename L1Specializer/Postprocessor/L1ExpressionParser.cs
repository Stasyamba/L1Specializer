// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2008
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.3.1.136 (2008-11-11)
// Machine:  macbook-pro-stas.local
// DateTime: 03.06.2011 0:20:19
// UserName: Stas
// Input file <L1ExpressionParser.y>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.Text;
using gppg;
using L1Specializer.SyntaxTree;
using L1Specializer.SyntaxTree.IfStatements;
using L1Specializer.Metadata;
using L1Runtime.SyntaxTree;

namespace L1Specializer.Postprocessor
{
public enum Tokens {
    error=1,EOF=2,INT=3,CHAR=4,BOOL=5,ARRAY=6,
    NEW=7,ARRAY_LENGTH=8,ASSERT=9,RETURN=10,DEFINE=11,END=12,
    NULL=13,T=14,F=15,WHILE=16,DO=17,TO=18,
    STEP=19,IF=20,THEN=21,ELSE=22,ELSIF=23,INTEGER=24,
    CHAR_LITERAL=25,IDENTIFIER=26,STRING_LITERAL=27,NOT=28,LP=29,RP=30,
    LAP=31,RAP=32,LFP=33,RFP=34,SEMI=35,COMMA=36,
    GOTO=37,PERIPERI=38,ILLEGAL=39,ASSIGN=40,OR=41,XOR=42,
    AND=43,EQ=44,NEQ=45,GR=46,GREQ=47,LE=48,
    LEEQ=49,PLUS=50,MINUS=51,MULT=52,DIV=53,MOD=54,
    POWER=55,UMINUS=56};

// Abstract base class for GPLEX scanners
public abstract class ScanBase : IScanner<L1Specializer.ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

public partial class L1ExpressionParser: ShiftReduceParser<L1Specializer.ValueType, LexLocation>
{
    private Dictionary<int, string> aliasses = null;

  protected override void Initialize()
  {
    this.errToken = (int)Tokens.error;
    this.eofToken = (int)Tokens.EOF;

    states=new State[77];
    AddState(0,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-1,1,-3,3,-7,70}));
    AddState(1,new State(new int[]{2,2}));
    AddState(2,new State(-1));
    AddState(3,new State(new int[]{40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37,2,-2}));
    AddState(4,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,5,-7,70}));
    AddState(5,new State(new int[]{40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37,2,-7,32,-7,30,-7,35,-7}));
    AddState(6,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,7,-7,70}));
    AddState(7,new State(new int[]{32,8,40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37}));
    AddState(8,new State(-8));
    AddState(9,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,10,-7,70}));
    AddState(10,new State(new int[]{40,-9,31,6,50,-9,51,-9,55,13,52,15,53,17,54,19,44,-9,45,-9,46,-9,47,-9,48,-9,49,-9,41,-9,43,-9,42,-9,2,-9,32,-9,30,-9,35,-9}));
    AddState(11,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,12,-7,70}));
    AddState(12,new State(new int[]{40,-10,31,6,50,-10,51,-10,55,13,52,15,53,17,54,19,44,-10,45,-10,46,-10,47,-10,48,-10,49,-10,41,-10,43,-10,42,-10,2,-10,32,-10,30,-10,35,-10}));
    AddState(13,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,14,-7,70}));
    AddState(14,new State(new int[]{40,-11,31,6,50,-11,51,-11,55,13,52,-11,53,-11,54,-11,44,-11,45,-11,46,-11,47,-11,48,-11,49,-11,41,-11,43,-11,42,-11,2,-11,32,-11,30,-11,35,-11}));
    AddState(15,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,16,-7,70}));
    AddState(16,new State(new int[]{40,-12,31,6,50,-12,51,-12,55,13,52,-12,53,-12,54,-12,44,-12,45,-12,46,-12,47,-12,48,-12,49,-12,41,-12,43,-12,42,-12,2,-12,32,-12,30,-12,35,-12}));
    AddState(17,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,18,-7,70}));
    AddState(18,new State(new int[]{40,-13,31,6,50,-13,51,-13,55,13,52,-13,53,-13,54,-13,44,-13,45,-13,46,-13,47,-13,48,-13,49,-13,41,-13,43,-13,42,-13,2,-13,32,-13,30,-13,35,-13}));
    AddState(19,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,20,-7,70}));
    AddState(20,new State(new int[]{40,-14,31,6,50,-14,51,-14,55,13,52,-14,53,-14,54,-14,44,-14,45,-14,46,-14,47,-14,48,-14,49,-14,41,-14,43,-14,42,-14,2,-14,32,-14,30,-14,35,-14}));
    AddState(21,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,22,-7,70}));
    AddState(22,new State(new int[]{40,-18,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,-18,45,-18,46,-18,47,-18,48,-18,49,-18,41,-18,43,-18,42,-18,2,-18,32,-18,30,-18,35,-18}));
    AddState(23,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,24,-7,70}));
    AddState(24,new State(new int[]{40,-19,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,-19,45,-19,46,-19,47,-19,48,-19,49,-19,41,-19,43,-19,42,-19,2,-19,32,-19,30,-19,35,-19}));
    AddState(25,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,26,-7,70}));
    AddState(26,new State(new int[]{40,-20,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,-20,45,-20,46,-20,47,-20,48,-20,49,-20,41,-20,43,-20,42,-20,2,-20,32,-20,30,-20,35,-20}));
    AddState(27,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,28,-7,70}));
    AddState(28,new State(new int[]{40,-21,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,-21,45,-21,46,-21,47,-21,48,-21,49,-21,41,-21,43,-21,42,-21,2,-21,32,-21,30,-21,35,-21}));
    AddState(29,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,30,-7,70}));
    AddState(30,new State(new int[]{40,-22,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,-22,45,-22,46,-22,47,-22,48,-22,49,-22,41,-22,43,-22,42,-22,2,-22,32,-22,30,-22,35,-22}));
    AddState(31,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,32,-7,70}));
    AddState(32,new State(new int[]{40,-23,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,-23,45,-23,46,-23,47,-23,48,-23,49,-23,41,-23,43,-23,42,-23,2,-23,32,-23,30,-23,35,-23}));
    AddState(33,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,34,-7,70}));
    AddState(34,new State(new int[]{40,-24,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,-24,43,35,42,-24,2,-24,32,-24,30,-24,35,-24}));
    AddState(35,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,36,-7,70}));
    AddState(36,new State(new int[]{40,-25,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,-25,43,-25,42,-25,2,-25,32,-25,30,-25,35,-25}));
    AddState(37,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,38,-7,70}));
    AddState(38,new State(new int[]{40,-26,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,-26,43,35,42,-26,2,-26,32,-26,30,-26,35,-26}));
    AddState(39,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,40,-7,70}));
    AddState(40,new State(-15));
    AddState(41,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,42,-7,70}));
    AddState(42,new State(new int[]{40,-16,31,6,50,-16,51,-16,55,13,52,15,53,17,54,19,44,-16,45,-16,46,-16,47,-16,48,-16,49,-16,41,-16,43,-16,42,-16,2,-16,32,-16,30,-16,35,-16}));
    AddState(43,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,44,-7,70}));
    AddState(44,new State(-17));
    AddState(45,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,46,-7,70}));
    AddState(46,new State(new int[]{30,47,40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37}));
    AddState(47,new State(-27));
    AddState(48,new State(new int[]{29,49}));
    AddState(49,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,50,-7,70}));
    AddState(50,new State(new int[]{30,51,40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37}));
    AddState(51,new State(-28));
    AddState(52,new State(new int[]{29,53,40,-32,31,-32,50,-32,51,-32,55,-32,52,-32,53,-32,54,-32,44,-32,45,-32,46,-32,47,-32,48,-32,49,-32,41,-32,43,-32,42,-32,2,-32,32,-32,30,-32,35,-32}));
    AddState(53,new State(new int[]{30,56,51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-6,54,-3,57,-7,70}));
    AddState(54,new State(new int[]{30,55}));
    AddState(55,new State(-29));
    AddState(56,new State(-30));
    AddState(57,new State(new int[]{35,58,40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37,30,-42}));
    AddState(58,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-6,59,-3,57,-7,70}));
    AddState(59,new State(-41));
    AddState(60,new State(new int[]{3,75,5,76},new int[]{-4,61,-5,74}));
    AddState(61,new State(new int[]{31,62,6,73}));
    AddState(62,new State(new int[]{51,39,50,41,28,43,29,45,8,48,26,52,7,60,24,65,25,66,14,67,15,68,13,69,27,71},new int[]{-3,63,-7,70}));
    AddState(63,new State(new int[]{32,64,40,4,31,6,50,9,51,11,55,13,52,15,53,17,54,19,44,21,45,23,46,25,47,27,48,29,49,31,41,33,43,35,42,37}));
    AddState(64,new State(-31));
    AddState(65,new State(-33));
    AddState(66,new State(-34));
    AddState(67,new State(-35));
    AddState(68,new State(-36));
    AddState(69,new State(-37));
    AddState(70,new State(-38));
    AddState(71,new State(new int[]{27,71,40,-40,31,-40,50,-40,51,-40,55,-40,52,-40,53,-40,54,-40,44,-40,45,-40,46,-40,47,-40,48,-40,49,-40,41,-40,43,-40,42,-40,2,-40,32,-40,30,-40,35,-40},new int[]{-7,72}));
    AddState(72,new State(-39));
    AddState(73,new State(-3));
    AddState(74,new State(-4));
    AddState(75,new State(-5));
    AddState(76,new State(-6));

    rules=new Rule[43];
    rules[1]=new Rule(-2, new int[]{-1,2});
    rules[2]=new Rule(-1, new int[]{-3});
    rules[3]=new Rule(-4, new int[]{-4,6});
    rules[4]=new Rule(-4, new int[]{-5});
    rules[5]=new Rule(-5, new int[]{3});
    rules[6]=new Rule(-5, new int[]{5});
    rules[7]=new Rule(-3, new int[]{-3,40,-3});
    rules[8]=new Rule(-3, new int[]{-3,31,-3,32});
    rules[9]=new Rule(-3, new int[]{-3,50,-3});
    rules[10]=new Rule(-3, new int[]{-3,51,-3});
    rules[11]=new Rule(-3, new int[]{-3,55,-3});
    rules[12]=new Rule(-3, new int[]{-3,52,-3});
    rules[13]=new Rule(-3, new int[]{-3,53,-3});
    rules[14]=new Rule(-3, new int[]{-3,54,-3});
    rules[15]=new Rule(-3, new int[]{51,-3});
    rules[16]=new Rule(-3, new int[]{50,-3});
    rules[17]=new Rule(-3, new int[]{28,-3});
    rules[18]=new Rule(-3, new int[]{-3,44,-3});
    rules[19]=new Rule(-3, new int[]{-3,45,-3});
    rules[20]=new Rule(-3, new int[]{-3,46,-3});
    rules[21]=new Rule(-3, new int[]{-3,47,-3});
    rules[22]=new Rule(-3, new int[]{-3,48,-3});
    rules[23]=new Rule(-3, new int[]{-3,49,-3});
    rules[24]=new Rule(-3, new int[]{-3,41,-3});
    rules[25]=new Rule(-3, new int[]{-3,43,-3});
    rules[26]=new Rule(-3, new int[]{-3,42,-3});
    rules[27]=new Rule(-3, new int[]{29,-3,30});
    rules[28]=new Rule(-3, new int[]{8,29,-3,30});
    rules[29]=new Rule(-3, new int[]{26,29,-6,30});
    rules[30]=new Rule(-3, new int[]{26,29,30});
    rules[31]=new Rule(-3, new int[]{7,-4,31,-3,32});
    rules[32]=new Rule(-3, new int[]{26});
    rules[33]=new Rule(-3, new int[]{24});
    rules[34]=new Rule(-3, new int[]{25});
    rules[35]=new Rule(-3, new int[]{14});
    rules[36]=new Rule(-3, new int[]{15});
    rules[37]=new Rule(-3, new int[]{13});
    rules[38]=new Rule(-3, new int[]{-7});
    rules[39]=new Rule(-7, new int[]{27,-7});
    rules[40]=new Rule(-7, new int[]{27});
    rules[41]=new Rule(-6, new int[]{-3,35,-6});
    rules[42]=new Rule(-6, new int[]{-3});

    nonTerminals = new string[] {"", "s", "$accept", "expression", "type", 
      "primitive_type", "va_list", "string_from_literals", };
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // s -> expression
{
				this.ParsedExpression = (L1Specializer.SyntaxTree.Expression)yyval.Tag;
			}
        break;
      case 3: // type -> type, ARRAY
{
				VariableType type = new VariableType(VariableTypeEnum.Array, (VariableType)value_stack.array[value_stack.top-2].Tag);
				yyval.Tag = type;
            }
        break;
      case 4: // type -> primitive_type
{
				yyval.Tag = value_stack.array[value_stack.top-1].Tag;
            }
        break;
      case 5: // primitive_type -> INT
{
				VariableType type = new VariableType(VariableTypeEnum.Integer);
				yyval.Tag = type;
            }
        break;
      case 6: // primitive_type -> BOOL
{
 				VariableType type = new VariableType(VariableTypeEnum.Bool);
 				yyval.Tag = type;
            }
        break;
      case 7: // expression -> expression, ASSIGN, expression
{ 	
                	Expression expr = new Expression();
					expr.OpType = OperationType.Assign;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 8: // expression -> expression, LAP, expression, RAP
{ 
                    Expression expr = new Expression();
					expr.OpType = OperationType.ArrayAccess;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-4].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-2].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 9: // expression -> expression, PLUS, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Plus;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 10: // expression -> expression, MINUS, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Minus;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 11: // expression -> expression, POWER, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Power;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 12: // expression -> expression, MULT, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Mult;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 13: // expression -> expression, DIV, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Div;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 14: // expression -> expression, MOD, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Mod;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 15: // expression -> MINUS, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.UMinus;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.RightNode = null;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 16: // expression -> PLUS, expression
{ 
					//TODO: Ã¯Ã°Ã®Ã¢Ã¥Ã°ÃªÃ  Ã­Ã  Ã­Ã¥ Bool
					yyval.Tag = value_stack.array[value_stack.top-1].Tag;
                }
        break;
      case 17: // expression -> NOT, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.UNot;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.RightNode = null;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 18: // expression -> expression, EQ, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Equals;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 19: // expression -> expression, NEQ, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.NotEquals;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 20: // expression -> expression, GR, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Gr;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 21: // expression -> expression, GREQ, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Greq;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 22: // expression -> expression, LE, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Le;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 23: // expression -> expression, LEEQ, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Leeq;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 24: // expression -> expression, OR, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Or;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 25: // expression -> expression, AND, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.And;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 26: // expression -> expression, XOR, expression
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.Xor;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-3].Tag;
					expr.RightNode = (Expression)value_stack.array[value_stack.top-1].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 
                }
        break;
      case 27: // expression -> LP, expression, RP
{ 
					yyval.Tag = value_stack.array[value_stack.top-2].Tag;
                }
        break;
      case 28: // expression -> ARRAY_LENGTH, LP, expression, RP
{
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.ArrayLength;
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-2].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 								
				}
        break;
      case 29: // expression -> IDENTIFIER, LP, va_list, RP
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.FunctionCall;
					expr.Value = value_stack.array[value_stack.top-4].sVal;
					expr.VAList = (VAList)value_stack.array[value_stack.top-2].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 					
                }
        break;
      case 30: // expression -> IDENTIFIER, LP, RP
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.FunctionCall;
					expr.Value = value_stack.array[value_stack.top-3].sVal;
					expr.VAList = new VAList();
					expr.Location = yyloc;
					yyval.Tag = expr; 					
                }
        break;
      case 31: // expression -> NEW, type, LAP, expression, RAP
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.ArrayAlloc;
					expr.Value = value_stack.array[value_stack.top-4].Tag;
					expr.ResultType = new VariableType(VariableTypeEnum.Array, (VariableType)value_stack.array[value_stack.top-4].Tag);
					expr.LeftNode = (Expression)value_stack.array[value_stack.top-2].Tag;
					expr.Location = yyloc;
					yyval.Tag = expr; 						
                }
        break;
      case 32: // expression -> IDENTIFIER
{ 
					//ÃÃ¾Ã¤Ã  Ã­Ã³Ã¦Ã­Ã® Ã¡Ã³Ã¤Ã¥Ã² Ã¥Ã¹Ã¥ Ã¤Ã®Ã¡Ã Ã¢Ã¨Ã²Ã¼ Ã²Ã¨Ã¯ Ã¯Ã¥Ã°Ã¥Ã¬Ã¥Ã­Ã­Ã®Ã© (Ã¤Ã«Ã¿ Ã±Ã¥Ã¬Ã Ã­Ã²Ã¨Ã·Ã¥Ã±ÃªÃ®Ã£Ã® Ã Ã­Ã Ã«Ã¨Ã§Ã )
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.VariableAccess;
					expr.Value = value_stack.array[value_stack.top-1].sVal;
					expr.Location = yyloc;
					yyval.Tag = expr; 						
                }
        break;
      case 33: // expression -> INTEGER
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.Constant;
					expr.IntValue = value_stack.array[value_stack.top-1].iVal;
					expr.ResultType = VariableType.IntType;
					expr.Location = yyloc;
					yyval.Tag = expr; 	                
                }
        break;
      case 34: // expression -> CHAR_LITERAL
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.Constant;
					expr.IntValue = value_stack.array[value_stack.top-1].iVal;
					expr.ResultType = VariableType.IntType;
					expr.Location = yyloc;
					yyval.Tag = expr;                 
                }
        break;
      case 35: // expression -> T
{ 
					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.Constant;
					expr.BoolValue = true;
					expr.ResultType = VariableType.BoolType;
					expr.Location = yyloc;
					yyval.Tag = expr;                 
                }
        break;
      case 36: // expression -> F
{ 
 					Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.Constant;
					expr.BoolValue = false;
					expr.ResultType = VariableType.BoolType;
					expr.Location = yyloc;
					yyval.Tag = expr;                
                }
        break;
      case 37: // expression -> NULL
{ 
                 	Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.Constant;
					expr.Value = null;
					expr.ResultType = VariableType.NullType;
					expr.Location = yyloc;
					yyval.Tag = expr;     
                }
        break;
      case 38: // expression -> string_from_literals
{
                 	Expression expr = new Expression();
					expr.OpType = OperationType.None;
					expr.IsLeaf = true;
					expr.LeafType = ExpressionLeafType.Constant;
					expr.Value = value_stack.array[value_stack.top-1].sVal;
					expr.ResultType = new VariableType(VariableTypeEnum.Array, VariableType.IntType);
					expr.Location = yyloc;
					yyval.Tag = expr;     					 
                }
        break;
      case 39: // string_from_literals -> STRING_LITERAL, string_from_literals
{
					yyval.sVal = value_stack.array[value_stack.top-2].sVal + value_stack.array[value_stack.top-1].sVal;
                }
        break;
      case 40: // string_from_literals -> STRING_LITERAL
{
					yyval.sVal = value_stack.array[value_stack.top-1].sVal;
                }
        break;
      case 41: // va_list -> expression, SEMI, va_list
{
					yyval.Tag = value_stack.array[value_stack.top-1].Tag;
					((VAList)yyval.Tag).AddForward((Expression)value_stack.array[value_stack.top-3].Tag);
                }
        break;
      case 42: // va_list -> expression
{
					VAList list = new VAList();
					list.Add((Expression)value_stack.array[value_stack.top-1].Tag);
					yyval.Tag = list;
                }
        break;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString())
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

}
}
